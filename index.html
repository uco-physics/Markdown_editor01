<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Editor</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://your-project.supabase.co; img-src 'self' data:;">
  <style>
    body { margin: 0; font-family: Arial, sans-serif; display: grid; grid-template-columns: 200px 1fr 1fr; height: 100vh; }
    #directory { background: #f0f0f0; padding: 10px; overflow-y: auto; }
    #editor { display: flex; flex-direction: column; }
    #editor textarea { flex: 1; resize: none; padding: 10px; font-family: monospace; font-size: 14px; }
    #preview { padding: 10px; overflow-y: auto; border-left: 1px solid #ccc; }
    #toolbar { display: flex; gap: 5px; padding: 5px; background: #e0e0e0; }
    .tree { cursor: pointer; }
    .tree-item { padding: 2px; }
    .tree-item:hover { background: #ddd; }
    .context-menu { position: absolute; background: white; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); }
    .context-menu div { padding: 5px; cursor: pointer; }
    .context-menu div:hover { background: #f0f0f0; }
    .theme-dark { background: #1e1e1e; color: #fff; }
    .theme-dark #directory { background: #2a2a2a; }
    .theme-dark #editor textarea { background: #1e1e1e; color: #fff; }
    .theme-dark #preview { background: #1e1e1e; }
  </style>
</head>
<body>
  <div id="directory"></div>
  <div id="editor">
    <div id="toolbar">
      <button onclick="saveFile()">Save</button>
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
      <button onclick="exportZip()">Export ZIP</button>
      <button onclick="exportHtml()">Export HTML</button>
      <button onclick="exportPdf()">Export PDF</button>
      <button onclick="toggleTheme()">Toggle Theme</button>
      <button onclick="searchReplace()">Search/Replace</button>
    </div>
    <textarea id="textarea" placeholder="Write Markdown here..."></textarea>
  </div>
  <div id="preview"></div>
  <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/lib/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/lib/core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/lib/languages/javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.7/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/yjs@13.6.18/dist/y.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/y-indexeddb@9.0.6/dist/y-indexeddb.min.js"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.13/dist/modules/libsodium-wrappers.min.js"></script>
  <script>
    // åˆæœŸåŒ–
    const db = new Dexie('MarkdownEditor');
    db.version(1).stores({ files: 'path, content, type, created, updated', history: 'id, path, content, timestamp' });
    const ydoc = new Y.Doc();
    const ytext = ydoc.getText('editor');
    const yProvider = new Y.IndexeddbProvider('markdown', ydoc);
    let currentFile = null;
    let encryptionKey;

    // æš—å·åŒ–åˆæœŸåŒ–
    async function initCrypto() {
      await sodium.ready;
      encryptionKey = sodium.crypto_secretbox_keygen();
    }
    initCrypto();

    // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ“ä½œ
    async function loadDirectory() {
      const files = await db.files.toArray();
      const tree = {};
      files.forEach(f => {
        const parts = f.path.split('/').filter(p => p);
        let current = tree;
        parts.forEach((part, i) => {
          if (!current[part]) current[part] = i === parts.length - 1 ? f : {};
          current = current[part];
        });
      });
      renderTree(tree, document.getElementById('directory'));
    }

    function renderTree(tree, parent, prefix = '') {
      parent.innerHTML = '';
      Object.keys(tree).sort().forEach(name => {
        const item = tree[name];
        const div = document.createElement('div');
        div.className = 'tree-item';
        div.textContent = (item.type === 'file' ? 'ðŸ“„' : 'ðŸ“') + ' ' + name;
        div.dataset.path = prefix + '/' + name;
        if (item.type === 'file') {
          div.onclick = () => loadFile(div.dataset.path);
        } else {
          div.onclick = () => toggleFolder(div);
          div.appendChild(document.createElement('div'));
        }
        parent.appendChild(div);
      });
    }

    function toggleFolder(div) {
      const subtree = div.querySelector('div');
      if (subtree.style.display === 'none') {
        subtree.style.display = 'block';
        renderTree(getSubtree(div.dataset.path), subtree, div.dataset.path);
      } else {
        subtree.style.display = 'none';
      }
    }

    function getSubtree(path) {
      // ç°¡ç•¥åŒ–ã®ãŸã‚ã€å®Ÿéš›ã¯db.filesã‹ã‚‰ã‚µãƒ–ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
      return {};
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
    async function loadFile(path) {
      currentFile = path;
      const file = await db.files.get({ path });
      ytext.delete(0, ytext.length);
      ytext.insert(0, file?.content || '');
      document.getElementById('textarea').value = ytext.toString();
      updatePreview();
    }

    async function saveFile() {
      if (!currentFile) return;
      const content = ytext.toString();
      const nonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
      const ciphertext = sodium.crypto_secretbox_easy(content, nonce, encryptionKey);
      await db.files.put({
        path: currentFile,
        content: JSON.stringify({ nonce, ciphertext }),
        type: 'file',
        created: Date.now(),
        updated: Date.now(),
      });
      await db.history.add({
        id: Date.now(),
        path: currentFile,
        content,
        timestamp: Date.now(),
      });
      notify('File saved');
    }

    // ã‚¨ãƒ‡ã‚£ã‚¿ã¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    const textarea = document.getElementById('textarea');
    textarea.addEventListener('input', () => {
      ytext.delete(0, ytext.length);
      ytext.insert(0, textarea.value);
      updatePreview();
      debounceSave();
    });

    ytext.observe(() => {
      textarea.value = ytext.toString();
      updatePreview();
    });

    function updatePreview() {
      const html = marked.parse(textarea.value, { breaks: true });
      const cleanHtml = DOMPurify.sanitize(html, { ADD_TAGS: ['img'], ADD_ATTR: ['src'] });
      document.getElementById('preview').innerHTML = cleanHtml;
      hljs.highlightAll();
      syncImages();
    }

    async function syncImages() {
      const images = document.querySelectorAll('#preview img');
      for (const img of images) {
        if (img.src.startsWith('file://')) {
          const path = img.src.replace('file://', '');
          const file = await db.files.get({ path });
          if (file && file.type === 'image') {
            img.src = file.content; // Data URL
          }
        }
      }
    }

    // è‡ªå‹•ä¿å­˜
    let saveTimeout;
    function debounceSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(saveFile, 500);
    }

    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†
    function undo() {
      ydoc.undoManager.undo();
    }

    function redo() {
      ydoc.undoManager.redo();
    }

    // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    async function exportZip() {
      const zip = new JSZip();
      const files = await db.files.toArray();
      files.forEach(f => {
        if (f.type === 'file') zip.file(f.path, f.content);
        else if (f.type === 'image') zip.file(f.path, f.content.split(',')[1], { base64: true });
      });
      const content = await zip.generateAsync({ type: 'blob' });
      download(content, 'markdown-editor.zip');
    }

    async function exportHtml() {
      const html = marked.parse(textarea.value, { breaks: true });
      const cleanHtml = DOMPurify.sanitize(html);
      download(new Blob([cleanHtml], { type: 'text/html' }), 'preview.html');
    }

    async function exportPdf() {
      const element = document.getElementById('preview');
      const opt = { margin: 1, filename: 'preview.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' } };
      html2pdf().from(element).set(opt).save();
    }

    function download(blob, name) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ãƒ†ãƒ¼ãƒžåˆ‡æ›¿
    function toggleTheme() {
      document.body.classList.toggle('theme-dark');
      localStorage.setItem('theme', document.body.classList.contains('theme-dark') ? 'dark' : 'light');
    }

    // æ¤œç´¢ç½®æ›
    function searchReplace() {
      const search = prompt('Search for:');
      if (!search) return;
      const replace = prompt('Replace with:');
      const regex = new RegExp(search, 'g');
      textarea.value = textarea.value.replace(regex, replace);
      ytext.delete(0, ytext.length);
      ytext.insert(0, textarea.value);
    }

    // é€šçŸ¥
    async function notify(message) {
      if (Notification.permission === 'granted') {
        new Notification('Markdown Editor', { body: message });
      } else {
        await Notification.requestPermission();
      }
    }

    // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', async e => {
      e.preventDefault();
      const files = e.dataTransfer.files;
      for (const file of files) {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = async () => {
            const path = `/images/${file.name}`;
            await db.files.put({ path, content: reader.result, type: 'image', created: Date.now(), updated: Date.now() });
            textarea.value += `![${file.name}](${path})\n`;
            ytext.insert(ytext.length, `![${file.name}](${path})\n`);
            loadDirectory();
          };
          reader.readAsDataURL(file);
        }
      }
    });

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
    document.getElementById('directory').addEventListener('contextmenu', e => {
      e.preventDefault();
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div onclick="newFile('${e.target.dataset.path}')">New File</div>
        <div onclick="newFolder('${e.target.dataset.path}')">New Folder</div>
        <div onclick="deleteItem('${e.target.dataset.path}')">Delete</div>
      `;
      menu.style.top = `${e.clientY}px`;
      menu.style.left = `${e.clientX}px`;
      document.body.appendChild(menu);
      document.addEventListener('click', () => menu.remove(), { once: true });
    });

    async function newFile(parentPath) {
      const name = prompt('File name:');
      if (name) {
        const path = `${parentPath}/${name}.md`;
        await db.files.put({ path, content: '', type: 'file', created: Date.now(), updated: Date.now() });
        loadDirectory();
      }
    }

    async function newFolder(parentPath) {
      const name = prompt('Folder name:');
      if (name) {
        const path = `${parentPath}/${name}`;
        await db.files.put({ path, content: '', type: 'folder', created: Date.now(), updated: Date.now() });
        loadDirectory();
      }
    }

    async function deleteItem(path) {
      if (confirm('Delete this item?')) {
        await db.files.where('path').startsWith(path).delete();
        loadDirectory();
      }
    }

    // åˆæœŸåŒ–
    window.onload = async () => {
      await loadDirectory();
      if (localStorage.getItem('theme') === 'dark') toggleTheme();
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
      if (!(await db.files.count())) {
        await db.files.put({ path: '/README.md', content: '# Welcome to Markdown Editor', type: 'file', created: Date.now(), updated: Date.now() });
        loadDirectory();
        loadFile('/README.md');
      }
    };

    // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    document.addEventListener('keydown', e => {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveFile();
      } else if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      } else if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
      } else if (e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        searchReplace();
      }
    });

    // ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œï¼‰
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(err => console.error('Service Worker error:', err));
    }
  </script>
</body>
</html>
