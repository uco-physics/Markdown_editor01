<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Editor</title>
  <!-- CDNライブラリ -->
  <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.7/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/yjs@13.6.18/dist/y.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/y-webrtc@10.2.6/dist/y-webrtc.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.13/dist/modules/libsodium-wrappers.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
  <style>
    /* レイアウト: VSCodeライクな3カラム */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #sidebar {
      width: 200px;
      background: #f0f0f0;
      overflow-y: auto;
      padding: 10px;
    }
    #editor {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    #editor textarea {
      flex: 1;
      resize: none;
      font-family: monospace;
      font-size: 14px;
    }
    #preview {
      width: 300px;
      background: #fff;
      overflow-y: auto;
      padding: 10px;
      border-left: 1px solid #ccc;
    }
    #directory {
      list-style: none;
      padding: 0;
    }
    #directory li {
      cursor: pointer;
      padding: 5px;
    }
    #directory li:hover {
      background: #ddd;
    }
    .folder > ul {
      display: none;
    }
    .folder.open > ul {
      display: block;
    }
    .toolbar {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }
    button {
      padding: 5px 10px;
    }
    /* テーマ */
    .dark {
      background: #1e1e1e;
      color: #fff;
    }
    .dark #sidebar {
      background: #252526;
    }
    .dark #editor textarea {
      background: #1e1e1e;
      color: #fff;
    }
    .dark #preview {
      background: #252526;
      color: #fff;
    }
  </style>
</head>
<body>
  <!-- 左: 擬似ディレクトリ -->
  <div id="sidebar">
    <div class="toolbar">
      <button onclick="createFile()">New File</button>
      <button onclick="createFolder()">New Folder</button>
      <button onclick="uploadFile()">Upload File</button>
    </div>
    <ul id="directory"></ul>
  </div>
  <!-- 中央: エディタ -->
  <div id="editor">
    <div class="toolbar">
      <button onclick="saveFile()">Save</button>
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
      <button onclick="commitVersion()">Commit</button>
      <button onclick="showHistory()">History</button>
      <button onclick="searchReplace()">Search/Replace</button>
      <button onclick="toggleTheme()">Toggle Theme</button>
      <button onclick="exportZip()">Export ZIP</button>
      <button onclick="exportHtml()">Export HTML</button>
      <button onclick="exportPdf()">Export PDF</button>
      <button onclick="startCollab()">Start Collab</button>
    </div>
    <textarea id="editor-text"></textarea>
  </div>
  <!-- 右: プレビュー -->
  <div id="preview"></div>

  <script>
    // 初期化
    const db = new Dexie('MarkdownEditorDB');
    db.version(1).stores({
      files: 'id, path, content, type, parentId',
      versions: 'id, fileId, content, timestamp, message',
      settings: 'key, value',
    });
    const ydoc = new Y.Doc();
    const ytext = ydoc.getText('editor');
    let currentFileId = null;
    let undoManager = null;
    let peer = null;
    let encryptionKey = null;

    // ライブラリ初期化
    hljs.registerLanguage('javascript', window.hljsDefineJavaScript);
    mermaid.initialize({ startOnLoad: false });

    // 暗号化初期化
    async function initCrypto() {
      await sodium.ready;
      encryptionKey = sodium.crypto_secretbox_keygen();
    }
    initCrypto();

    // ディレクトリ操作
    async function renderDirectory() {
      const files = await db.files.toArray();
      const directory = document.getElementById('directory');
      directory.innerHTML = '';
      const tree = buildTree(files, null);
      directory.appendChild(renderTree(tree));
    }

    function buildTree(files, parentId) {
      return files
        .filter(f => f.parentId === parentId)
        .map(f => ({
          ...f,
          children: f.type === 'folder' ? buildTree(files, f.id) : [],
        }));
    }

    function renderTree(nodes) {
      const ul = document.createElement('ul');
      nodes.forEach(node => {
        const li = document.createElement('li');
        li.textContent = node.path.split('/').pop();
        li.draggable = true;
        li.dataset.id = node.id;
        if (node.type === 'folder') {
          li.classList.add('folder');
          li.addEventListener('click', () => li.classList.toggle('open'));
          li.appendChild(renderTree(node.children));
        } else {
          li.addEventListener('click', () => openFile(node.id));
        }
        li.addEventListener('dragstart', e => e.dataTransfer.setData('text/plain', node.id));
        li.addEventListener('drop', e => handleDrop(e, node.id));
        li.addEventListener('dragover', e => e.preventDefault());
        ul.appendChild(li);
      });
      return ul;
    }

    async function createFile() {
      const path = prompt('File name:');
      if (path) {
        const id = Date.now().toString();
        await db.files.put({ id, path: `/root/${path}`, content: '', type: 'file', parentId: null });
        renderDirectory();
      }
    }

    async function createFolder() {
      const path = prompt('Folder name:');
      if (path) {
        const id = Date.now().toString();
        await db.files.put({ id, path: `/root/${path}`, content: '', type: 'folder', parentId: null });
        renderDirectory();
      }
    }

    async function uploadFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*,.md';
      input.onchange = async e => {
        const file = e.target.files[0];
        const id = Date.now().toString();
        const reader = new FileReader();
        reader.onload = async () => {
          const content = file.type.startsWith('image/') ? reader.result : await file.text();
          await db.files.put({
            id,
            path: `/root/${file.name}`,
            content,
            type: file.type.startsWith('image/') ? 'image' : 'file',
            parentId: null,
          });
          renderDirectory();
        };
        if (file.type.startsWith('image/')) reader.readAsDataURL();
        else reader.readAsText(file);
      };
      input.click();
    }

    async function handleDrop(e, targetId) {
      const sourceId = e.dataTransfer.getData('text/plain');
      await db.files.update(sourceId, { parentId: targetId });
      renderDirectory();
    }

    // エディタ操作
    async function openFile(id) {
      currentFileId = id;
      const file = await db.files.get(id);
      const editor = document.getElementById('editor-text');
      editor.value = file.content;
      ytext.delete(0, ytext.length);
      ytext.insert(0, file.content);
      if (!undoManager) {
        undoManager = new Y.UndoManager(ytext);
      }
      renderPreview(file.content);
    }

    function renderPreview(content) {
      const preview = document.getElementById('preview');
      const html = marked.parse(content, {
        async: false,
        breaks: true,
        gfm: true,
        sanitizer: DOMPurify.sanitize,
      });
      preview.innerHTML = html;
      // コードハイライト
      preview.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
      // KaTeX数式
      preview.querySelectorAll('span.math').forEach(el => {
        katex.render(el.textContent, el, { throwOnError: false });
      });
      // Mermaidダイアグラム
      preview.querySelectorAll('pre.mermaid').forEach(el => {
        mermaid.render('mermaid-' + Date.now(), el.textContent, svg => {
          el.innerHTML = svg;
        });
      });
      // 画像リンク解決
      preview.querySelectorAll('img').forEach(img => {
        const src = img.getAttribute('src');
        db.files.where('path').equals(src).first().then(file => {
          if (file && file.type === 'image') img.src = file.content;
        });
      });
    }

    // 自動保存
    let autoSaveTimeout;
    document.getElementById('editor-text').addEventListener('input', () => {
      clearTimeout(autoSaveTimeout);
      autoSaveTimeout = setTimeout(saveFile, 5000);
      const content = document.getElementById('editor-text').value;
      ytext.delete(0, ytext.length);
      ytext.insert(0, content);
      renderPreview(content);
    });

    async function saveFile() {
      if (currentFileId) {
        const content = document.getElementById('editor-text').value;
        await db.files.update(currentFileId, { content });
        console.log('Saved');
      }
    }

    // バージョン管理
    async function commitVersion() {
      if (currentFileId) {
        const message = prompt('Commit message:');
        const content = document.getElementById('editor-text').value;
        await db.versions.put({
          id: Date.now().toString(),
          fileId: currentFileId,
          content,
          timestamp: new Date(),
          message,
        });
        console.log('Committed');
      }
    }

    async function showHistory() {
      if (currentFileId) {
        const versions = await db.versions.where('fileId').equals(currentFileId).toArray();
        const ul = document.createElement('ul');
        versions.forEach(v => {
          const li = document.createElement('li');
          li.textContent = `${v.timestamp}: ${v.message}`;
          li.onclick = () => {
            document.getElementById('editor-text').value = v.content;
            renderPreview(v.content);
          };
          ul.appendChild(li);
        });
        document.getElementById('preview').innerHTML = '';
        document.getElementById('preview').appendChild(ul);
      }
    }

    // Undo/Redo
    function undo() {
      if (undoManager) undoManager.undo();
      document.getElementById('editor-text').value = ytext.toString();
      renderPreview(ytext.toString());
    }

    function redo() {
      if (undoManager) undoManager.redo();
      document.getElementById('editor-text').value = ytext.toString();
      renderPreview(ytext.toString());
    }

    // 検索/置換
    function searchReplace() {
      const search = prompt('Search:');
      const replace = prompt('Replace with:');
      if (search && replace) {
        const editor = document.getElementById('editor-text');
        editor.value = editor.value.replace(new RegExp(search, 'g'), replace);
        saveFile();
        renderPreview(editor.value);
      }
    }

    // テーマ切り替え
    function toggleTheme() {
      document.body.classList.toggle('dark');
      db.settings.put({ key: 'theme', value: document.body.classList.contains('dark') ? 'dark' : 'light' });
    }

    // エクスポート
    async function exportZip() {
      const zip = new JSZip();
      const files = await db.files.toArray();
      files.forEach(file => {
        if (file.type === 'file' || file.type === 'image') {
          zip.file(file.path.replace('/root/', ''), file.content);
        }
      });
      const content = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(content);
      a.download = 'markdown-editor.zip';
      a.click();
    }

    async function exportHtml() {
      const content = document.getElementById('preview').innerHTML;
      const blob = new Blob([content], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'preview.html';
      a.click();
    }

    async function exportPdf() {
      const element = document.getElementById('preview');
      await html2pdf().from(element).save('preview.pdf');
    }

    // リアルタイムコラボ
    function startCollab() {
      const provider = new WebrtcProvider('markdown-editor-room', ydoc);
      provider.on('sync', () => console.log('Collaborators synced'));
      ytext.observe(() => {
        document.getElementById('editor-text').value = ytext.toString();
        renderPreview(ytext.toString());
      });
    }

    // 初期化
    async function init() {
      await renderDirectory();
      const theme = await db.settings.get('theme');
      if (theme && theme.value === 'dark') document.body.classList.add('dark');
      // Service Workerでオフライン対応
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js').catch(err => console.error('Service Worker error:', err));
      }
    }
    init();

    // ショートカット
    document.addEventListener('keydown', e => {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveFile();
      }
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
      }
    });
  </script>
</body>
</html>
